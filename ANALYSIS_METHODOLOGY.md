# 문제 해결 중심 오픈소스 분석 방법론
## Problem-Driven Open Source Analysis Methodology

---

## 🎯 핵심 철학

> **코드는 문제를 해결하기 위한 의사결정의 결과물이다**

이 방법론의 목표는 "코드가 무엇을 하는가"가 아니라 **"왜 이런 선택을 했는가"**를 이해하는 것입니다.

### 기존 분석 vs 문제 중심 분석

| 기존 분석 (What) | 문제 중심 분석 (Why) |
|------------------|---------------------|
| 이 함수는 무엇을 하는가? | 어떤 문제를 해결하려고 이 함수를 만들었는가? |
| 이 클래스의 메서드는? | 왜 하나의 클래스가 아니라 여러 클래스로 나눴는가? |
| 폴더 구조는 어떻게 되어있는가? | 왜 이런 폴더 구조를 선택했는가? 어떤 문제를 해결하는가? |
| 디자인 패턴은? | 왜 이 패턴을 사용했는가? 다른 선택지는 없었는가? |

---

## 📋 분석 프레임워크: "문제 → 고민 → 해결"

모든 코드를 다음 3단계로 분석합니다:

### 1. 문제 (Problem)
- 어떤 문제를 해결하려고 하는가?
- 문제가 없었다면 어떤 불편함이 있었을까?
- 누구를 위한 문제인가? (개발자? 사용자? 시스템?)

### 2. 고민 (Consideration)
- 어떤 선택지들이 있었는가?
- 각 선택지의 장단점은?
- 왜 다른 방법을 선택하지 않았는가?

### 3. 해결 (Solution)
- 최종적으로 어떤 방법을 선택했는가?
- 이 해결책의 트레이드오프는?
- 어떤 부분을 희생하고 어떤 부분을 얻었는가?

---

## 🔍 레벨별 분석 질문

코드의 각 레벨에서 물어봐야 할 질문들:

### 📁 Level 1: 폴더/모듈 구조

**문제**
- 왜 이렇게 폴더를 나눴는가?
- 하나의 큰 폴더가 아니라 여러 개로 분리한 이유는?
- 각 폴더의 책임(responsibility)은 명확한가?

**고민**
- 다른 구조 방식은? (예: 기능별 vs 레이어별 vs 도메인별)
- 왜 이 방식을 선택했는가?
- 순환 참조(circular dependency) 문제는 어떻게 해결했는가?

**해결**
- 최종 구조가 해결한 문제는?
- 이 구조의 장점은? (예: 코드 찾기 쉬움, 의존성 관리 명확)
- 단점은? (예: 폴더가 너무 많아서 복잡)

**분석 예시**
```
❌ "src/ 폴더에는 소스 코드가 있고, tests/ 폴더에는 테스트가 있다"

✅ "src/를 network/, protocol/, client/로 나눈 이유:
   - 문제: 하나의 폴더에 모든 코드가 섞이면 의존성 관리가 어렵다
   - 고민: 기능별로 나눌까 vs 계층별로 나눌까?
   - 해결: 계층별 분리 → 하위 계층은 상위 계층을 몰라도 됨 (단방향 의존성)"
```

---

### 📦 Level 2: 클래스/파일 분리

**문제**
- 왜 이 클래스를 만들었는가?
- 여러 클래스로 나눈 이유는? 하나로 합치면 안 되는가?
- 어떤 책임을 분리하려고 했는가?

**고민**
- 상속 vs 컴포지션 중 무엇을 선택했는가?
- 추상 클래스 vs 인터페이스 중 무엇을 사용했는가?
- 클래스 크기는 적절한가? (너무 크거나 작지 않은가)

**해결**
- 최종 클래스 구조의 이점은?
- 어떤 변경에 강한가? (예: 새로운 기능 추가 시)
- 어떤 변경에 약한가? (예: 기존 로직 변경 시)

**분석 예시**
```
❌ "Producer 클래스는 메시지를 전송한다"

✅ "Producer를 RecordAccumulator, Sender로 분리한 이유:
   - 문제: 배치 처리와 네트워크 전송을 하나의 클래스에서 하면 복잡도 증가
   - 고민: 하나의 큰 클래스 vs 여러 작은 클래스?
   - 해결: SRP(단일 책임 원칙) 적용
     - RecordAccumulator: 메시지 모으기 (메모리 관리)
     - Sender: 네트워크 전송 (I/O 관리)
   - 이점: 각각 독립적으로 테스트 가능, 배치 로직 변경 시 네트워크 코드 영향 없음"
```

---

### 🔧 Level 3: 함수/메서드 설계

**문제**
- 이 함수가 해결하는 문제는?
- 왜 이 함수를 분리했는가?
- 파라미터 개수와 타입 선택 이유는?

**고민**
- 동기 vs 비동기?
- 에러를 throw할까 vs return할까?
- 파라미터를 많이 받을까 vs 객체로 받을까?
- 제네릭을 사용할까 vs 구체 타입을 사용할까?

**해결**
- 최종 함수 시그니처의 장점은?
- 사용하기 쉬운가? (API 관점)
- 확장하기 쉬운가? (내부 구현 관점)

**분석 예시**
```
❌ "send() 함수는 메시지를 전송한다"

✅ "send()가 async 함수인 이유:
   - 문제: 네트워크 전송은 느리다 (수십~수백ms)
   - 고민:
     - 동기: 간단하지만 호출자를 블록함
     - 비동기: 복잡하지만 다른 작업과 동시 실행 가능
     - 콜백: 간단하지만 콜백 지옥 위험
   - 해결: async/await 선택
     - 이유: Python 3.5+ 표준, 코드 가독성 좋음
     - 트레이드오프: Python 3.4 이하 지원 불가"
```

---

### 🎨 Level 4: 디자인 패턴 선택

**문제**
- 어떤 복잡성을 해결하려고 패턴을 사용했는가?
- 패턴 없이 구현했다면 어떤 문제가 있었을까?

**고민**
- 이 패턴 vs 저 패턴?
- 패턴을 쓰지 않는 선택지는?
- 오버 엔지니어링은 아닌가?

**해결**
- 최종 패턴의 이점은?
- 코드가 복잡해지지 않았는가?
- 다른 개발자가 이해하기 쉬운가?

**분석 예시**
```
❌ "Connection Pool 패턴을 사용한다"

✅ "Connection Pool 패턴을 사용한 이유:
   - 문제: 매번 TCP 연결 생성은 비용이 크다 (3-way handshake)
   - 고민:
     1. 매번 새 연결: 간단하지만 느림
     2. 하나의 연결 재사용: 빠르지만 동시 요청 불가
     3. Connection Pool: 복잡하지만 성능과 동시성 모두 확보
   - 해결: Pool 사용 + 최소/최대 연결 수 설정
     - min_connections=1: 최소한의 리소스 사용
     - max_connections=10: 부하 분산
   - 트레이드오프: 메모리 사용량 증가 vs 성능 향상"
```

---

### 🏗️ Level 5: 아키텍처 전체

**문제**
- 전체 시스템이 해결하려는 핵심 문제는?
- 왜 이런 계층 구조를 선택했는가?

**고민**
- Monolithic vs Layered vs Microservices?
- 동기 vs 비동기 아키텍처?
- 강한 결합 vs 느슨한 결합?

**해결**
- 전체 아키텍처의 이점은?
- 확장성은?
- 유지보수성은?

**분석 예시**
```
❌ "네트워크, 프로토콜, 클라이언트, 애플리케이션 레이어로 구성되어 있다"

✅ "Layered Architecture를 선택한 이유:
   - 문제: Kafka 프로토콜이 복잡하고 자주 변경됨
   - 고민:
     - Flat 구조: 간단하지만 변경 영향이 전체에 퍼짐
     - Layered 구조: 복잡하지만 변경 영역이 제한됨
   - 해결: 4개 레이어로 분리
     - Network Layer: TCP/SASL (프로토콜 독립적)
     - Protocol Layer: Kafka 바이너리 프로토콜
     - Client Layer: 메타데이터, 라우팅
     - Application Layer: Producer/Consumer API
   - 이점:
     - Kafka 프로토콜 변경 시 Protocol Layer만 수정
     - 다른 프로토콜 추가 시 Network Layer 재사용 가능
   - 단점:
     - 레이어 간 데이터 전달 비용 (직접 호출보다 느림)"
```

---

## 📊 분석 범위 선택

프로젝트 분석 시 **3가지 접근 방식**이 있습니다. 상황에 따라 선택하세요.

### 방법 1: 패턴 중심 분석 (Pattern-Focused)

**언제 사용?**
- 특정 패턴/개념을 깊이 이해하고 싶을 때
- 여러 파일에 걸쳐 있는 패턴을 분석할 때
- 학습 목적: "이 패턴이 어떻게 동작하는지" 이해

**예시**:
```
analysis/
├── patterns/
│   ├── connection-pool.md        # Connection Pool 패턴
│   ├── correlation-id.md         # 요청/응답 매칭
│   ├── sasl-authentication.md    # 인증 메커니즘
│   └── version-negotiation.md    # API 버전 협상
```

**장점**:
- ✅ 패턴에 집중 → 깊이 있는 학습
- ✅ 재사용 가능한 지식 추출
- ✅ 비슷한 상황에 바로 적용 가능

**단점**:
- ❌ 전체 프로젝트 커버리지 부족
- ❌ 패턴 간 연결 파악 어려움

---

### 방법 2: 파일별 분석 (File-Focused) ⭐ 추천

**언제 사용?**
- 프로젝트 전체를 체계적으로 이해하고 싶을 때
- 각 파일의 역할과 책임을 명확히 하고 싶을 때
- 참고 문서로 활용할 때

**예시**:
```
analysis/
├── conn.py.md              # 연결 관리 (5가지 기능 분석)
├── client.py.md            # Connection Pool, 메타데이터
├── cluster.py.md           # 클러스터 정보 관리
├── producer_overview.md    # Producer 전체 흐름
└── consumer_overview.md    # Consumer 전체 흐름
```

**장점**:
- ✅ 전체 프로젝트 커버리지 확보
- ✅ 파일 단위로 참고 용이
- ✅ 각 파일 내에서 여러 패턴 분석 가능

**단점**:
- ❌ 파일이 크면 분석 시간 오래 걸림
- ❌ 파일 간 연결 설명 추가 필요

**파일별 분석 구조** (각 파일마다):
```markdown
# <파일명> - <역할 한 줄 설명>

## 파일 개요
- 경로, 줄 수, 주요 클래스
- 핵심 역할

## 해결하는 핵심 문제들

### 문제 1: <이름>
- 문제: ...
- 고민: 선택지 A vs B vs C
- 해결: 최종 선택 + 이유
- 트레이드오프: ...

### 문제 2: <이름>
- 문제: ...
- 고민: ...
- 해결: ...

(파일 내 주요 기능들을 각각 "문제→고민→해결"로 분석)

## 전체 흐름

## 실전 적용 가이드 ⭐ 중요
- 가이드 1: <패턴 이름> 구현하기
- 가이드 2: <패턴 이름> 구현하기
(Step-by-step으로 실제 프로젝트 적용 방법 제시)

## 안티패턴과 흔한 실수 ⭐ 중요
- 실수 1: <문제 설명>
- 실수 2: <문제 설명>
(나쁜 예 + 문제점 + 좋은 예)

## 스케일 고려사항 ⭐ 중요
- 소규모: ...
- 중규모: ...
- 대규모: ...
(규모별 다른 전략 제시)

## 배운 점
## 비슷한 상황에 적용
```

**새로운 3가지 필수 섹션:**

1. **실전 적용 가이드**: 실제 프로젝트에서 바로 쓸 수 있는 템플릿 + 단계별 가이드
2. **안티패턴**: 흔한 실수를 미리 알려줘서 같은 실수 반복 방지
3. **스케일 고려사항**: 규모에 따라 다른 전략 (소/중/대 규모)

---

### 방법 3: 프로젝트 전체 분석 (Project-Wide)

**언제 사용?**
- 아키텍처 전체를 이해하고 싶을 때
- 레이어 간 상호작용을 파악할 때
- 큰 그림을 먼저 보고 싶을 때

**예시**:
```
analysis/
├── 00_ARCHITECTURE_SUMMARY.md   # 전체 아키텍처
├── 01_network_layer.md           # 레이어별 분석
├── 02_protocol_layer.md
├── 03_client_layer.md
└── 04_application_layer.md
```

**장점**:
- ✅ 전체 구조 이해
- ✅ 레이어 간 연결 명확

**단점**:
- ❌ 세부 사항 부족
- ❌ 깊이 있는 학습 어려움

---

### 어떤 방법을 선택할까?

| 상황 | 추천 방법 |
|------|-----------|
| 처음 접하는 프로젝트 | 방법 2 (파일별) + 방법 3 (전체 요약) |
| 특정 패턴만 배우고 싶음 | 방법 1 (패턴 중심) |
| 참고 문서 만들기 | 방법 2 (파일별) |
| 빠르게 큰 그림 파악 | 방법 3 (프로젝트 전체) |

**이 방법론의 기본 접근**: **방법 2 (파일별) 우선**
- 각 파일을 "문제 → 고민 → 해결" 관점으로 분석
- 전체 커버리지 확보 + 깊이 있는 학습

---

## ✨ 실전 적용을 위한 3가지 핵심 섹션

모든 파일 분석에 다음 3가지 섹션을 **반드시** 포함해야 합니다.

### 1. 실전 적용 가이드 (Practical Application Guides)

**목적**: 분석한 패턴을 실제 프로젝트에 바로 적용할 수 있게 돕기

**작성 방법:**

```markdown
## 실전 적용 가이드

### 가이드 1: <패턴 이름> 구현하기

**상황**: <언제 이 패턴을 사용하는가?>

#### Step 1: 요구사항 정의
- [ ] 체크리스트 형태로 요구사항 제시
- [ ] 이 패턴이 필요한 상황 파악

#### Step 2: 기본 구현
<완전한 코드 예시>

#### Step 3: 의사결정 체크리스트
| 상황 | 선택 |
|------|------|
| A 조건 | 방법 1 |
| B 조건 | 방법 2 |
```

**예시 (Connection Pool 가이드):**
```python
# Step 1: 요구사항 정의
- [ ] 서버 개수가 동적으로 변하는가?
- [ ] 연결이 끊어질 수 있는가?

# Step 2: 기본 구현
class ConnectionPool:
    def __init__(self):
        self._conns = {}
        self._lock = asyncio.Lock()

    async def get_connection(self, node_id):
        # 완전한 구현...
```

**핵심:**
- 복사해서 바로 쓸 수 있는 코드
- 단계별로 설명 (Step 1, 2, 3)
- 의사결정 기준 명시

---

### 2. 안티패턴과 흔한 실수 (Anti-patterns & Common Mistakes)

**목적**: 같은 실수를 반복하지 않도록 미리 알려주기

**작성 방법:**

```markdown
## 안티패턴과 흔한 실수

### 실수 1: <실수 이름>

**❌ 나쁜 예:**
<실제 잘못된 코드>

**문제:**
- 왜 잘못되었는가?
- 어떤 문제가 발생하는가?

**✅ 좋은 예:**
<올바른 코드>
```

**예시 (Lock 안에서 I/O):**
```markdown
### 실수 1: Lock 안에서 느린 작업

**❌ 나쁜 예:**
```python
def update_config(self):
    with self._lock:  # Lock 시작
        data = requests.get("...").json()  # I/O!
        self._config = data
```

**문제:**
- Lock 시간 = I/O 시간 (초 단위)
- 모든 읽기 Task 대기

**✅ 좋은 예:**
```python
async def update_config(self):
    # Lock 밖에서 I/O
    data = await fetch_data()

    # Lock 안에서 교체만
    with self._lock:
        self._config = data
```
```

**핵심:**
- 나쁜 예 → 문제 설명 → 좋은 예 순서
- 실제 발생 가능한 실수
- 코드로 명확히 보여주기

---

### 3. 스케일 고려사항 (Scale Considerations)

**목적**: 규모에 따라 다른 전략이 필요함을 알려주기

**작성 방법:**

```markdown
## 스케일 고려사항

### 소규모 (기준 명시, 예: 연결 < 10)

**권장 사항:**
- ✅ 간단한 구현도 OK
- ⚠️  복잡한 최적화 불필요

**구현 예시:**
<간단한 코드>

**모니터링:**
- 기본 메트릭만

---

### 중규모 (기준 명시, 예: 연결 10-100)

**권장 사항:**
- ✅ 패턴 적용 필요
- ✅ 메트릭 수집 시작

**구현 예시:**
<중간 복잡도 코드>

**모니터링:**
- 상세 메트릭

---

### 대규모 (기준 명시, 예: 연결 100+)

**권장 사항:**
- ✅ 고급 최적화 필수
- ✅ 모니터링/알림 필수

**구현 예시:**
<고급 코드 (Sharding, Circuit Breaker 등)>

**모니터링:**
- Prometheus 스타일 메트릭 예시
```

**예시 (Connection Pool 스케일):**
```markdown
### 소규모 (연결 < 10)
- ✅ 간단한 딕셔너리 Pool
- ⚠️  Lock 경합 거의 없음

class SimplePool:
    def __init__(self):
        self._conns = {}  # 간단!

### 중규모 (연결 10-100)
- ✅ Lock + Double-check
- ✅ Health check 추가

class MediumPool:
    def __init__(self):
        self._conns = {}
        self._lock = asyncio.Lock()
        self._metrics = {}  # 메트릭 수집

### 대규모 (연결 100+)
- ✅ Shard별 Lock (경합 분산)
- ✅ Circuit Breaker

class LargePool:
    def __init__(self, shards=10):
        self._shards = [...]  # Sharding!
```

**핵심:**
- 명확한 기준 (숫자로 명시)
- 규모별 다른 전략
- 실제 코드 예시 + 모니터링 가이드

---

## 🛠️ 실전 분석 프로세스

### Step 1: 프로젝트 탐색 (10분)

```bash
# 폴더 구조 확인
tree -L 2 -d

# 파일 크기 확인
find . -name "*.py" | xargs wc -l | sort -rn | head -20
```

**질문하기**
- 왜 이렇게 폴더를 나눴을까?
- 가장 큰 파일은 무엇이고, 왜 큰가?
- 순환 참조는 없는가?

### Step 2: 입구 찾기 (15분)

**사용자가 가장 먼저 사용하는 코드 찾기**
- README 예제 코드 확인
- `__init__.py` 에서 export하는 클래스 확인
- 가장 많이 import되는 파일 찾기

```bash
# 가장 많이 import되는 파일 찾기
grep -r "from \." --include="*.py" | cut -d: -f2 | sort | uniq -c | sort -rn
```

**질문하기**
- 왜 이 API를 메인 입구로 선택했는가?
- 더 간단한 API는 없었는가?
- 사용자 경험(UX)을 위한 고민이 보이는가?

### Step 3: 핵심 흐름 추적 (30분)

**하나의 기능을 끝까지 따라가기**

예: "메시지 전송" 흐름
```
producer.send(msg)
  → RecordAccumulator.append(msg)
    → Sender.run()
      → KafkaClient.send()
        → Connection.send_bytes()
          → socket.sendall()
```

**각 단계에서 질문하기**
- 왜 여기서 이 처리를 하는가?
- 왜 다음 레이어로 넘기는가?
- 어떤 책임을 분리했는가?

### Step 4: "왜"를 찾기 (45분)

**코드만 보지 말고 맥락 찾기**

1. **주석 읽기**: 왜 이렇게 했는지 설명이 있을 수 있음
2. **Commit 메시지 읽기**: `git log -p <file>` - 왜 이 코드를 추가했는지
3. **이슈/PR 읽기**: 어떤 문제를 해결하려고 했는지
4. **테스트 코드 읽기**: 어떤 엣지 케이스를 고려했는지

```bash
# 파일의 주요 변경 이력 보기
git log --oneline --follow <file> | head -10

# 특정 함수가 언제 추가되었는지
git log -S "def function_name" --source --all
```

### Step 5: 대안 생각하기 (20분)

**"나라면 어떻게 했을까?" 질문하기**

- 더 간단한 방법은 없었을까?
- 왜 이 방법이 더 나은가?
- 어떤 것을 포기하고 어떤 것을 얻었는가?

**예시**
```python
# 실제 코드
class Producer:
    def __init__(self, bootstrap_servers, **config):
        self._accumulator = RecordAccumulator(...)
        self._sender = Sender(...)

    async def send(self, topic, value):
        await self._accumulator.append(...)

# 대안 1: 더 간단한 방법
class SimpleProducer:
    async def send(self, topic, value):
        # 직접 전송 (배치 없음)
        conn = await connect(server)
        await conn.send(value)

# 왜 대안 1을 선택하지 않았는가?
# → 배치 처리 불가능, 매번 연결 생성, 성능 낮음

# 대안 2: 더 복잡한 방법
class ComplexProducer:
    # 파티션별, 토픽별로 각각 다른 설정...

# 왜 대안 2를 선택하지 않았는가?
# → 오버 엔지니어링, 대부분의 사용자는 필요 없음
```

### Step 6: 문서화 (30분)

**"문제 → 고민 → 해결" 템플릿으로 작성**

```markdown
# <Component Name>

## 해결하려는 문제
- 문제 상황 설명
- 이 문제가 없었다면 어떤 불편함?
- 누구를 위한 해결책인가?

## 고민했던 선택지

### 선택지 1: <이름>
- 설명
- 장점: ...
- 단점: ...
- 왜 선택하지 않았는가: ...

### 선택지 2: <이름>
- 설명
- 장점: ...
- 단점: ...

### 선택지 3 (최종 선택): <이름>
- 설명
- 장점: ...
- 단점: ...
- 왜 선택했는가: ...

## 최종 해결책

### 구조
<코드 또는 다이어그램>

### 핵심 아이디어
- 어떤 문제를 어떻게 해결했는가
- 트레이드오프는 무엇인가

### 실제 코드 예시
```python
<실제 사용 예시>
```

## 배운 점
- 이 코드에서 배운 문제 해결 접근법
- 비슷한 상황에서 적용할 수 있는 인사이트
```

---

## 💡 분석 팁

### 1. "왜"를 3번 물어보기

```
Q: 왜 이 클래스를 만들었는가?
A: 메시지를 모으기 위해

Q: 왜 메시지를 모아야 하는가?
A: 배치로 보내면 효율적이니까

Q: 왜 배치가 효율적인가?
A: 네트워크 왕복 비용이 크기 때문에 한 번에 여러 개 보내는 게 빠름

→ 진짜 문제: 네트워크 I/O 최적화
```

### 2. 주석보다 코드 구조 보기

```python
# ❌ 주석만 믿지 말기
# This is a simple function
def complex_function(a, b, c, d, e, f, g):  # 실제로는 복잡함
    ...

# ✅ 코드 구조로 의도 파악하기
class MessageBatch:
    """문제: 메시지를 하나씩 보내면 느림"""

    def add_message(self, msg):
        """고민: 언제 배치를 보낼까?"""
        self._messages.append(msg)
        if len(self._messages) >= self.batch_size:
            self.flush()  # 해결: 크기 기반 전송
```

### 3. 테스트로 의도 파악하기

```python
# 테스트는 "이 코드가 해결하려는 문제"를 보여줌
def test_connection_pool_reuses_connection():
    """문제: 매번 새 연결 생성은 느림"""
    pool = ConnectionPool()
    conn1 = pool.get()
    pool.release(conn1)
    conn2 = pool.get()
    assert conn1 is conn2  # 해결: 연결 재사용
```

### 4. 에러 처리로 고민 파악하기

```python
# 에러 처리는 "어떤 케이스를 고민했는지" 보여줌
try:
    await self._sender.send(msg)
except BufferFullError:
    # 고민: 버퍼가 가득 차면?
    # 선택지 1: 예외 발생 (사용자가 처리)
    # 선택지 2: 기다리기 (블록킹)
    # 선택지 3: 오래된 메시지 삭제
    await asyncio.sleep(0.1)  # 해결: 잠깐 기다리기
    raise  # 그래도 안 되면 예외
```

### 5. 설정(Config)으로 트레이드오프 파악하기

```python
class Producer:
    def __init__(
        self,
        linger_ms=0,  # 고민: 지연 vs 처리량
        batch_size=16384,  # 고민: 메모리 vs 효율
        max_in_flight_requests=5,  # 고민: 순서 보장 vs 동시성
    ):
        # 설정값 = 사용자가 선택할 수 있는 트레이드오프
```

---

## 📝 분석 예시

### 예시 1: 왜 Connection Pool을 사용하는가?

#### 문제
- Kafka에 메시지를 보내려면 TCP 연결 필요
- 매번 새 연결 생성 시 3-way handshake (수 ms)
- 초당 1000개 메시지 전송 시 매우 느림

#### 고민했던 선택지

**선택지 1: 매번 새 연결**
```python
async def send(msg):
    conn = await create_connection()
    await conn.send(msg)
    await conn.close()
```
- 장점: 간단, 연결 관리 불필요
- 단점: 느림, 리소스 낭비
- 왜 안 됨: 성능 요구사항 불만족

**선택지 2: 하나의 연결 재사용**
```python
conn = await create_connection()
async def send(msg):
    await conn.send(msg)
```
- 장점: 빠름, 간단
- 단점: 동시 요청 불가능 (순차 처리만 가능)
- 왜 안 됨: 비동기 환경에서 병목

**선택지 3 (최종): Connection Pool**
```python
pool = ConnectionPool(min_size=1, max_size=10)
async def send(msg):
    conn = await pool.acquire()
    try:
        await conn.send(msg)
    finally:
        await pool.release(conn)
```
- 장점: 빠름 + 동시 요청 가능
- 단점: 복잡함, 메모리 사용
- 왜 선택: 성능과 동시성 모두 필요

#### 배운 점
- 네트워크 프로그래밍에서는 연결 재사용이 중요
- Pool 패턴은 리소스 재사용 + 동시성 제어에 유용
- 설정값(min/max)으로 트레이드오프 조절 가능

---

### 예시 2: 왜 클래스를 여러 개로 나눴는가?

#### 문제
- Producer는 메시지 전송 외에도:
  - 메시지 직렬화
  - 파티션 선택
  - 배치 처리
  - 압축
  - 재시도
  - 메타데이터 관리
- 하나의 클래스에 모두 넣으면 수천 줄

#### 고민했던 선택지

**선택지 1: 하나의 큰 클래스**
```python
class Producer:
    def send(self, msg):
        # 직렬화
        # 파티션 선택
        # 배치에 추가
        # 압축
        # 전송
        # 재시도
        ...  # 너무 길어짐
```
- 장점: 간단한 구조
- 단점: 테스트 어려움, 변경 영향 큼, 이해 어려움

**선택지 2 (최종): 책임별로 분리**
```python
class Producer:
    def __init__(self):
        self._serializer = Serializer()
        self._partitioner = Partitioner()
        self._accumulator = RecordAccumulator()
        self._sender = Sender()

    def send(self, msg):
        data = self._serializer.serialize(msg)
        partition = self._partitioner.partition(msg)
        self._accumulator.append(partition, data)
        # Sender는 백그라운드에서 동작
```
- 장점: 각 컴포넌트 독립 테스트, SRP, 변경 영향 제한
- 단점: 클래스 많음, 데이터 전달 비용

#### 해결책의 핵심
- **단일 책임 원칙 (SRP)**: 각 클래스는 하나의 이유로만 변경됨
  - Serializer: 직렬화 방식 변경 시
  - Partitioner: 파티션 로직 변경 시
  - RecordAccumulator: 배치 정책 변경 시
  - Sender: 네트워크 로직 변경 시

#### 배운 점
- 복잡한 로직은 작은 단위로 쪼개기
- 각 컴포넌트의 "변경 이유"가 다르면 분리
- 테스트 가능성이 설계 검증 지표

---

### 예시 3: 파일별 분석 (aiokafka conn.py)

**파일**: `aiokafka/conn.py` (918 lines)
**목표**: 파일 전체를 분석하되, 각 기능마다 "문제→고민→해결" 적용

#### 파일 개요
이 파일은 **Kafka 브로커와의 개별 연결**을 관리합니다:
- TCP 연결 생성 (asyncio)
- SASL 인증 (5가지 방식)
- 비동기 요청/응답 처리
- Idle 연결 관리
- API 버전 협상

#### 분석한 5가지 핵심 문제

**1. TCP 연결과 비동기 I/O**
- 문제: 비동기 환경에서 TCP 연결 관리, 버퍼 크기 제어 필요
- 고민: `asyncio.open_connection()` vs 저수준 API
- 해결: 저수준 API (StreamReader/Writer) + 커스텀 Protocol
- 트레이드오프: 복잡도 증가 vs 완전한 제어

**2. SASL 인증 (5가지 방식)**
- 문제: PLAIN, GSSAPI, SCRAM, OAuth 모두 지원해야 함
- 고민: if-else 분기 vs 플러그인 아키텍처
- 해결: `BaseSaslAuthenticator` 추상 클래스 + 각 방식별 구현체
- 트레이드오프: 클래스 증가 vs 확장성

**3. 비동기 요청/응답 매칭**
- 문제: 응답 순서가 요청과 다를 수 있음
- 고민: Queue(순서대로) vs Correlation ID
- 해결: Correlation ID + deque + Future
- 트레이드오프: 구현 복잡도 vs 동시성

**4. Idle 연결 관리**
- 문제: 사용하지 않는 연결은 리소스 낭비
- 고민: 계속 유지 vs ping vs timeout
- 해결: Idle timeout (기본 9분) + weakref
- 트레이드오프: 재연결 비용 vs 리소스 절약

**5. API Version Negotiation**
- 문제: 브로커 버전마다 프로토콜 다름
- 고민: 고정 버전 vs 사용자 설정 vs 자동 협상
- 해결: ApiVersionRequest로 자동 협상
- 트레이드오프: 추가 RTT vs UX

#### 문서 구조

```markdown
# conn.py - Kafka 연결 관리

## 파일 개요

## 해결하는 핵심 문제들

### 1. TCP 연결과 비동기 I/O
- 문제
- 고민했던 선택지 (3개)
- 최종 해결책 (코드 + 설명)
- 핵심 아이디어

### 2. SASL 인증 - 5가지 방식
- (동일 구조)

... (5개 문제 각각 분석)

## 전체 연결 흐름
## 주요 클래스/메서드 참고
## 배운 점 (8가지)
## 비슷한 상황에 적용
```

#### 이 방식의 장점

- ✅ **전체 커버리지**: 파일의 모든 주요 기능 분석
- ✅ **깊이 있는 학습**: 각 기능마다 "왜"를 파고듦
- ✅ **참고 용이**: 파일 이름으로 빠르게 찾기
- ✅ **패턴 추출**: 여러 패턴을 하나의 문서에서 학습

#### 실제 문서 예시

실제 분석 문서: `projects/aiokafka/analysis-v2/conn.py.md`
- 분량: ~800 lines
- 5가지 문제 × "문제→고민→해결" 구조
- 8가지 배운 점 정리
- 적용 가능한 케이스 명시

---

## 🎯 체크리스트

### 분석 완료 기준

각 컴포넌트 분석 시 아래 질문에 답할 수 있어야 함:

- [ ] **문제**: 이 코드가 없었다면 어떤 불편함이 있었는가?
- [ ] **대안**: 다른 방법은 없었는가? 각 장단점은?
- [ ] **선택**: 왜 이 방법을 선택했는가?
- [ ] **트레이드오프**: 무엇을 얻고 무엇을 포기했는가?
- [ ] **적용**: 비슷한 상황에서 이 패턴을 사용할 수 있는가?

---

## 🚀 시작하기

### 첫 프로젝트 분석 시

1. **작은 컴포넌트부터 시작** (100-300 줄 정도)
2. **하나의 기능만 추적** (예: 메시지 전송)
3. **"왜"를 최소 3번 물어보기**
4. **대안 생각해보기** (나라면 어떻게?)
5. **배운 점 정리** (다음에 어떻게 적용?)

### 추천 분석 순서

1. **README 예제 코드** → 사용자 입구 이해
2. **메인 API 클래스** → 전체 흐름 파악
3. **핵심 내부 컴포넌트** → 문제 해결 방법 학습
4. **유틸리티/헬퍼** → 세부 테크닉 학습

---

## 📚 학습 목표

이 방법론을 사용하면:

1. **문제 정의 능력**: 코드 작성 전에 "왜"를 명확히 하기
2. **선택지 평가 능력**: 여러 방법 중 최선 고르기
3. **트레이드오프 사고**: 완벽한 해결책은 없다는 것 이해
4. **패턴 적용 능력**: 비슷한 문제에 배운 패턴 적용
5. **설계 의사결정**: 아키텍처 결정의 근거 만들기

---

## 💬 마무리

> "좋은 코드는 문제를 명확히 이해하고, 신중하게 선택하고, 트레이드오프를 수용한 결과입니다"

단순히 코드를 읽지 말고, **개발자가 했던 고민을 따라가 보세요**.
그 과정에서 진짜 문제 해결력이 자랍니다.
