# 프롬프트: 심층 오픈소스 분석 가이드

## 🎯 최종 목표
이 분석의 목표는 단순히 코드의 기능을 나열하는 것을 넘어, **"왜 이 프로젝트가 이런 구조를 갖게 되었는가"**와 **"각 코드 구성 요소(클래스, 함수 등)가 어떤 구체적인 목적을 위해 구현되었는가"**를 심층적으로 이해하는 것입니다.

---

## Phase 1: 프로젝트 전체 그림 이해 (High-Level Understanding)

**목표**: 프로젝트의 존재 이유와 핵심 아키텍처를 파악합니다.

1.  **핵심 문제 정의**: 이 프로젝트가 해결하고자 하는 가장 중요한 문제는 무엇입니까? (한두 문장으로 요약)
2.  **기술 스택 및 의존성**: 사용된 주요 기술, 프레임워크, 라이브러리는 무엇이며, 각각 어떤 역할을 합니까?
3.  **아키텍처 시각화**:
    *   주요 컴포넌트와 데이터 흐름을 나타내는 아키텍처 다이어그램을 Mermaid.js를 사용하여 작성해 주세요.
    *   사용자 요청 또는 데이터 입력부터 최종 출력까지의 과정을 설명하는 시퀀스 다이어그램을 추가하면 좋습니다.

---

## Phase 2: 구조 분석 (Structural Analysis)

**목표**: "왜 이런 폴더/파일 구조를 선택했는가?"에 대한 답을 찾습니다.

1.  **디렉토리 구조 분석**:
    *   최상위 디렉토리부터 시작하여 각 하위 디렉토리의 역할을 설명해 주세요.
    *   예: `src` (핵심 소스 코드), `tests` (테스트 코드), `docs` (문서), `config` (설정 파일) 등
2.  **구조의 목적성**:
    *   이러한 디렉토리 구조가 프로젝트의 어떤 목표(예: 유지보수성, 확장성, 관심사 분리, 팀 협업)를 달성하기 위해 설계되었는지 분석해 주세요.
    *   특정 문제 해결 방식이 어떻게 구조에 반영되었는지 설명해 주세요. (예: "대규모 데이터 처리를 위해 데이터 파이프라인 단계를 폴더별로 분리함")

---

## Phase 3: 파일 단위 심층 분석 (Detailed File-Level Analysis)

**목표**: 각 파일과 그 안의 코드(클래스, 함수)가 존재하는 이유를 명확히 밝힙니다.

**프로세스**:
- 프로젝트의 핵심 기능에 가장 중요한 **핵심 소스 파일들(core source files)을 식별**합니다. (예: 5~10개 내외)
- 식별된 **각 핵심 파일에 대해**, 동일한 이름의 `.md` 파일을 생성하여 분석 내용을 기록합니다.
- 예: `src/core/logic.py`가 핵심 파일이라면 `src/core/logic.py.md` 파일 생성

**각 `[파일명].md`에 포함될 내용**:

1.  **파일의 핵심 역할 (File's Purpose)**
    *   이 파일이 프로젝트 전체에서 담당하는 핵심적인 역할은 무엇인지 한 문장으로 요약합니다.

2.  **주요 구성 요소 분석 (Key Components Analysis)**
    *   **클래스 (Class)**:
        *   **책임 (Responsibility)**: 이 클래스의 핵심 책임은 무엇입니까? 어떤 데이터를 캡슐화하고, 어떤 동작을 수행합니까?
        *   **상태 (State)**: 관리하는 주요 상태(멤버 변수, 프로퍼티)는 무엇이며, 각각 어떤 의미를 갖습니까?
        *   **설계 이유**: 왜 이 로직을 별도의 클래스로 분리했을까요? 얻는 이점은 무엇입니까?
    *   **함수 / 메서드 (Function / Method)**:
        *   **목적 (Purpose)**: 이 함수의 명확한 목적은 무엇입니까? (예: "사용자 인증 토큰 생성", "데이터베이스에서 주문 내역 조회")
        *   **입력 (Inputs)**: 어떤 파라미터를 받으며, 각 파라미터의 의미는 무엇입니까?
        *   **출력 (Outputs)**: 무엇을 반환하며, 반환 값의 의미는 무엇입니까?
        *   **핵심 로직**: 내부의 핵심적인 로직은 어떤 순서로 동작합니까? (복잡할 경우 단계별 설명)
    *   **변수 / 상수 (Variables / Constants)**:
        *   파일 레벨의 중요한 변수나 상수가 있다면 그 목적과 의미를 설명합니다.

3.  **상호작용 및 연결성 (Interactions & Connectivity)**
    *   이 파일(또는 내부의 클래스/함수)은 어떤 다른 파일/모듈과 상호작용합니까?
    *   어떤 함수를 호출하고, 어떤 클래스에 의해 호출됩니까?

---

## Phase 5: 실행 흐름 및 동적 분석 (Execution Flow & Dynamic Analysis)

**목표**: 프로젝트의 핵심 커맨드를 실행했을 때, 내부적으로 어떤 일들이 어떤 순서로 일어나는지 단계별로 이해합니다.

**프로세스**:

1.  **핵심 실행 커맨드 식별**
    *   이 프로젝트를 실행하고 사용하는 데 필요한 핵심 커맨드를 식별합니다. (예: `dbt run`, `dbt test`, `npm start`, `python main.py`)

2.  **커맨드별 실행 흐름 분석**
    *   각 핵심 커맨드에 대해, "실행 시 어떤 일이 일어나는가?"를 단계별 시나리오로 설명합니다.
    *   **입력(Input)**: 커맨드 실행에 필요한 것은 무엇입니까? (예: 소스 코드 파일, 데이터베이스 연결 정보, 환경 변수)
    *   **처리(Process)**: 내부적으로 어떤 작업들이 수행됩니까? (예: dbt가 DAG를 생성하고 순서대로 SQL 실행, 웹서버가 요청을 받아 컨트롤러-서비스-리포지토리 순으로 처리)
    *   **출력(Output)**: 실행의 최종 결과물은 무엇입니까? (예: 데이터베이스에 테이블/뷰 생성, API 응답, 콘솔 로그)

3.  **dbt 프로젝트 예시**:
    *   `dbt run` 실행 시: dbt가 `ref` 관계를 파싱하여 DAG(의존성 그래프)를 만들고, 어떤 순서로 모델들을 실행하며, 각 모델의 SQL이 어떻게 `CREATE TABLE/VIEW ... AS` 구문으로 변환되어 데이터 웨어하우스에 전송되는지 설명합니다.
    *   `dbt test` 실행 시: dbt가 `schema.yml` 파일을 읽고, 각 테스트(예: `not_null`)를 어떻게 실패 케이스를 찾는 SQL 쿼리(예: `select count(*) from ... where column is null`)로 변환하여 실행하는지 설명합니다.

---

## Phase 6: 종합 및 요약 (Synthesis and Summary)

**목표**: 분석된 내용을 종합하여 프로젝트에 대한 완전한 이해를 구축합니다.

1.  **`_ANALYSIS_SUMMARY.md` 파일 생성**:
    *   프로젝트의 핵심 문제 해결 방식을 구조적, 기능적, 동적 관점에서 종합적으로 서술합니다.
    *   Phase 3과 5에서 생성된 모든 개별 `.md` 분석 파일로 연결되는 링크 목록을 제공합니다.
    *   가장 흥미로웠던 설계 결정이나 문제 해결 방식 3가지를 선정하여 요약합니다.

---

> **최종 원칙**: 모든 분석은 "What(무엇)"을 넘어 **"Why(왜)"**에 초점을 맞춥니다. "왜 이 코드가 여기에, 이런 방식으로 존재하는가?"를 끊임없이 질문하고 답을 찾으세요.
